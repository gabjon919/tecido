<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Tecido com Girosc√≥pio</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  background: #0f1220;
  overflow: hidden;
}

canvas {
  display: block;
  touch-action: none;
}

.hint {
  position: fixed;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  font-family: monospace;
  font-size: 12px;
  color: #bbb;
  opacity: 0.8;
  text-align: center;
}
</style>
</head>
<body>

<canvas id="canvas"></canvas>
<div class="hint">
  Arraste devagar = vento üå¨Ô∏è<br>
  Arraste r√°pido = rasga üßµ<br>
  Incline o celular = movimento üì±
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = innerWidth;
canvas.height = innerHeight;

const GRAVITY = 0.4;
const FRICTION = 0.999;
const SPACING = 15;
const TEAR_DISTANCE = 80;
const ROWS = 35;
const COLS = Math.floor(canvas.width / SPACING);

let windX = 0;
let windY = 0;

let pointer = { x:0, y:0, px:0, py:0, down:false };

class Point {
  constructor(x, y, pinned=false) {
    this.x = x;
    this.y = y;
    this.oldx = x;
    this.oldy = y;
    this.pinned = pinned;
    this.constraints = [];
  }

  update() {
    if (this.pinned) return;

    let vx = (this.x - this.oldx) * FRICTION;
    let vy = (this.y - this.oldy) * FRICTION;

    this.oldx = this.x;
    this.oldy = this.y;

    this.x += vx + windX;
    this.y += vy + GRAVITY + windY;

    if (pointer.down) {
      let dx = this.x - pointer.x;
      let dy = this.y - pointer.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      let speed = Math.abs(pointer.x-pointer.px) + Math.abs(pointer.y-pointer.py);

      if (dist < 25) {
        if (speed > 25) {
          this.constraints = [];
        } else {
          this.x += (pointer.x - pointer.px) * 0.5;
          this.y += (pointer.y - pointer.py) * 0.5;
        }
      }
    }
  }

  draw() {
    this.constraints.forEach(c => c.draw());
  }
}

class Constraint {
  constructor(p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
    this.length = SPACING;
  }

  update() {
    let dx = this.p2.x - this.p1.x;
    let dy = this.p2.y - this.p1.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > TEAR_DISTANCE) return;

    let diff = (this.length - dist) / dist;
    let ox = dx * diff * 0.5;
    let oy = dy * diff * 0.5;

    if (!this.p1.pinned) {
      this.p1.x -= ox;
      this.p1.y -= oy;
    }
    if (!this.p2.pinned) {
      this.p2.x += ox;
      this.p2.y += oy;
    }
  }

  draw() {
    ctx.beginPath();
    ctx.moveTo(this.p1.x, this.p1.y);
    ctx.lineTo(this.p2.x, this.p2.y);
    ctx.strokeStyle = "#6fa8dc";
    ctx.stroke();
  }
}

let points = [];

function createCloth() {
  points = [];
  for (let y=0; y<ROWS; y++) {
    for (let x=0; x<COLS; x++) {
      let p = new Point(x*SPACING+40, y*SPACING+20, y===0);
      if (x>0) p.constraints.push(new Constraint(p, points[points.length-1]));
      if (y>0) p.constraints.push(new Constraint(p, points[(y-1)*COLS+x]));
      points.push(p);
    }
  }
}

function update() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  points.forEach(p => p.update());
  for (let i=0;i<5;i++) points.forEach(p => p.constraints.forEach(c => c.update()));
  points.forEach(p => p.draw());
  requestAnimationFrame(update);
}

/* ===== Mouse + Touch ===== */
function setPointer(x,y){
  pointer.px = pointer.x;
  pointer.py = pointer.y;
  pointer.x = x;
  pointer.y = y;
}

canvas.addEventListener("mousedown",e=>{
  pointer.down=true;
  setPointer(e.clientX,e.clientY);
});
canvas.addEventListener("mousemove",e=>{
  if(pointer.down) setPointer(e.clientX,e.clientY);
});
canvas.addEventListener("mouseup",()=>pointer.down=false);
canvas.addEventListener("mouseleave",()=>pointer.down=false);

canvas.addEventListener("touchstart",e=>{
  pointer.down=true;
  const t=e.touches[0];
  setPointer(t.clientX,t.clientY);
});
canvas.addEventListener("touchmove",e=>{
  const t=e.touches[0];
  setPointer(t.clientX,t.clientY);
});
canvas.addEventListener("touchend",()=>pointer.down=false);

/* ===== Girosc√≥pio ===== */
function handleGyro(e){
  windX = e.gamma * 0.03;
  windY = e.beta * 0.02;
}

function enableGyro(){
  if (typeof DeviceOrientationEvent !== "undefined" &&
      typeof DeviceOrientationEvent.requestPermission === "function") {

    const btn = document.createElement("button");
    btn.innerText = "Ativar movimento üì±";
    btn.style.position="fixed";
    btn.style.top="20px";
    btn.style.left="50%";
    btn.style.transform="translateX(-50%)";
    btn.style.padding="10px";
    btn.style.zIndex=10;

    btn.onclick=()=>{
      DeviceOrientationEvent.requestPermission().then(p=>{
        if(p==="granted"){
          window.addEventListener("deviceorientation",handleGyro);
          btn.remove();
        }
      });
    };
    document.body.appendChild(btn);
  } else {
    window.addEventListener("deviceorientation",handleGyro);
  }
}

createCloth();
update();
enableGyro();

window.addEventListener("resize",()=>{
  canvas.width=innerWidth;
  canvas.height=innerHeight;
  createCloth();
});
</script>

</body>
</html>
