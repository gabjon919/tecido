<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Tecido Interativo ‚Äì Mouse & Touch</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #0f1220;
    overflow: hidden;
  }

  canvas {
    display: block;
    touch-action: none; /* MUITO IMPORTANTE para celular */
  }

  .hint {
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-family: monospace;
    color: #bbb;
    font-size: 13px;
    opacity: 0.7;
    text-align: center;
  }
</style>
</head>
<body>

<canvas id="canvas"></canvas>
<div class="hint">
  Arraste devagar = vento üå¨Ô∏è<br>
  Arraste r√°pido = rasga üßµ
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const GRAVITY = 0.4;
const FRICTION = 0.999;
const TEAR_DISTANCE = 80;
const SPACING = 15;
const COLS = Math.floor(canvas.width / SPACING);
const ROWS = 35;

let pointer = {
  x: 0,
  y: 0,
  px: 0,
  py: 0,
  down: false
};

class Point {
  constructor(x, y, pinned = false) {
    this.x = x;
    this.y = y;
    this.oldx = x;
    this.oldy = y;
    this.pinned = pinned;
    this.constraints = [];
  }

  update() {
    if (this.pinned) return;

    let vx = (this.x - this.oldx) * FRICTION;
    let vy = (this.y - this.oldy) * FRICTION;

    this.oldx = this.x;
    this.oldy = this.y;

    this.x += vx;
    this.y += vy + GRAVITY;

    if (pointer.down) {
      let dx = this.x - pointer.x;
      let dy = this.y - pointer.y;
      let dist = Math.sqrt(dx * dx + dy * dy);
      let speed = Math.abs(pointer.x - pointer.px) + Math.abs(pointer.y - pointer.py);

      if (dist < 25) {
        if (speed > 25) {
          this.constraints = [];
        } else {
          this.x += (pointer.x - pointer.px) * 0.5;
          this.y += (pointer.y - pointer.py) * 0.5;
        }
      }
    }
  }

  draw() {
    this.constraints.forEach(c => c.draw());
  }
}

class Constraint {
  constructor(p1, p2) {
    this.p1 = p1;
    this.p2 = p2;
    this.length = SPACING;
  }

  update() {
    let dx = this.p2.x - this.p1.x;
    let dy = this.p2.y - this.p1.y;
    let dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > TEAR_DISTANCE) return;

    let diff = (this.length - dist) / dist;
    let offx = dx * diff * 0.5;
    let offy = dy * diff * 0.5;

    if (!this.p1.pinned) {
      this.p1.x -= offx;
      this.p1.y -= offy;
    }

    if (!this.p2.pinned) {
      this.p2.x += offx;
      this.p2.y += offy;
    }
  }

  draw() {
    ctx.beginPath();
    ctx.moveTo(this.p1.x, this.p1.y);
    ctx.lineTo(this.p2.x, this.p2.y);
    ctx.strokeStyle = "#6fa8dc";
    ctx.stroke();
  }
}

let points = [];

function createCloth() {
  points = [];

  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      let p = new Point(
        x * SPACING + 50,
        y * SPACING + 20,
        y === 0
      );

      if (x > 0) {
        p.constraints.push(new Constraint(p, points[points.length - 1]));
      }

      if (y > 0) {
        p.constraints.push(new Constraint(p, points[(y - 1) * COLS + x]));
      }

      points.push(p);
    }
  }
}

function update() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  points.forEach(p => p.update());

  for (let i = 0; i < 5; i++) {
    points.forEach(p => p.constraints.forEach(c => c.update()));
  }

  points.forEach(p => p.draw());

  requestAnimationFrame(update);
}

/* ===== UNIFICA MOUSE + TOUCH ===== */
function setPointer(x, y) {
  pointer.px = pointer.x;
  pointer.py = pointer.y;
  pointer.x = x;
  pointer.y = y;
}

canvas.addEventListener("mousedown", e => {
  pointer.down = true;
  setPointer(e.clientX, e.clientY);
});

canvas.addEventListener("mousemove", e => {
  if (!pointer.down) return;
  setPointer(e.clientX, e.clientY);
});

canvas.addEventListener("mouseup", () => pointer.down = false);
canvas.addEventListener("mouseleave", () => pointer.down = false);

canvas.addEventListener("touchstart", e => {
  pointer.down = true;
  const t = e.touches[0];
  setPointer(t.clientX, t.clientY);
});

canvas.addEventListener("touchmove", e => {
  const t = e.touches[0];
  setPointer(t.clientX, t.clientY);
});

canvas.addEventListener("touchend", () => pointer.down = false);

createCloth();
update();

window.addEventListener("resize", () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  createCloth();
});
</script>

</body>
</html>
